00:02:30	read.ai meeting notes:	Oryn added read.ai meeting notes to the meeting.

Read provides AI generated meeting summaries to make meetings more effective and efficient. View our Privacy Policy at https://www.read.ai/pp

Type "read stop" to disable, or "opt out" to delete meeting data.
00:04:35	Fireflies.ai Notetaker Jay:	Jay invited Fireflies.ai here to record & take notes. View Security & Privacy info: https://fireflies.ai/policy

Type:
'/ff leave' - Remove Fireflies

View Realtime notes here: https://app.fireflies.ai/live/01KHP2EJX4XHC4AZ4MWBSBVSVB?ref=live_chat
00:18:11	Danno Ferrin - Tectonic.xyz:	This is all with 32 byte pubkeys?
00:19:54	Fab:	Must the used state stay private? Otherwise, we could attach it to the transaction.
00:20:07	Fab:	So the chain itself keeps track of this
00:23:36	Mike:	Replying to "This is all with 32 ..."

Yes
16 bytes seed, 16 bytes hash output
00:24:09	Mike:	Replying to "Must the used state ..."

The state can be public, but the problem is that some transactions/signatures may not end up on the chain
00:24:14	Parthasarathy Ramanujam:	How is this different from the Ethereum Foundation‚Äôs XMSS paper released last year? Is 2^20, 2^64 you mentioned earlier refers to lifetime? https://github.com/leanEthereum/leanSig
00:25:07	Mike:	Replying to "So the chain itself ..."

The problem that we can not guarantee that the signature will end up on the chain in 100% of the cases.
00:26:17	Fab:	Replying to "So the chain itself ..."

True, but the wallet could be keeping track of that. In this case the only corner case is when you try to land a tx, it doesn't get through, you do nothing afterwards, and then reset the wallet. Still far from perfect but at least the surface is reduced.
00:26:39	Mike:	Replying to "How is this differen..."

Etherum approach focused on the stateful signing with a "balanced" XMSS. We explored stateless parameters. Moreover, the aim for Etherum project was to optimize  the SNARK-ing
00:26:51	Fab:	Replying to "So the chain itself ..."

Another solution could be a public server akin to the former MIT GPG one. This server aggregates state and periodically rolls it up on-chain.
00:27:15	Parthasarathy Ramanujam:	Reacted to "Etherum approach foc..." with üëç
00:27:25	Wolfgang Vitale:	Reacted to "Etherum approach foc..." with üëç
00:28:49	Mike:	Replying to "So the chain itself ..."

Reusing the state is a security problem, so for it is drastic for any user if the state is reused. I would not trust an external server with my state :)
00:29:02	Parthasarathy Ramanujam:	Does this is uses keccak256 hash? @Nicolas Consigny
00:29:09	Kigen Fukuda:	Reacted to "Etherum approach foc..." with üëç