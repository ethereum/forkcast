WEBVTT

1
00:02:50.760 --> 00:02:51.780
Zsolt Felföldi: Hello?

2
00:02:55.850 --> 00:02:57.369
Tamaghna Choudhuri: Hello, how are you?

3
00:02:58.820 --> 00:03:05.720
Zsolt Felföldi: Great. Yeah, a little bit tired, I might eat Denver now, so it's morning, but yeah.

4
00:03:06.490 --> 00:03:13.740
Tamaghna Choudhuri: Oh, yeah. Oh, well, you just said that you'd be presenting this stuff at it then, so, like, is it today or some other day?

5
00:03:15.260 --> 00:03:26.619
Zsolt Felföldi: it's on Thursday, so, I presented, also, so there was Eat Border, last week, and I also, did the presentation on Saturday.

6
00:03:26.630 --> 00:03:37.429
Zsolt Felföldi: And, and, and yes, I, I will, also present, there's this EF Day, on, on Thursday at Denver, so, yeah.

7
00:03:37.860 --> 00:03:42.200
Zsolt Felföldi: I will also do… Oh, that's moved there, so yeah.

8
00:03:43.020 --> 00:03:45.940
Tamaghna Choudhuri: Yeah, Lynn, did you get any,

9
00:03:46.050 --> 00:03:56.690
Tamaghna Choudhuri: feedback from the devs, like, let's say the wallet devs, or the daps devs, so how do they feel about this thing? So, did you… were you able to get something like that from them?

10
00:03:56.690 --> 00:04:04.710
Zsolt Felföldi: So right now, it's mostly the… the core developers who, are, really…

11
00:04:04.890 --> 00:04:08.120
Zsolt Felföldi: Paying attention to this, because, like, it's, like…

12
00:04:08.260 --> 00:04:10.900
Zsolt Felföldi: fairly technical, so, like, I think,

13
00:04:11.030 --> 00:04:27.269
Zsolt Felföldi: Maybe at eDenver… in Denver, maybe there will be more people, so at… at Border, it's a really small conference, so this was, like, a room of, I don't know, 30 people, maybe 40, and, also.

14
00:04:27.420 --> 00:04:31.670
Zsolt Felföldi: From, from various areas, and EOF.

15
00:04:32.000 --> 00:04:48.860
Zsolt Felföldi: Yeah, so it would be good to… it would be great to hear from someone from the, like, user side, but it's still, like, so this is… this is the EIP, and it's not even the API specification, so I think maybe at this point, it's,

16
00:04:48.980 --> 00:04:56.530
Zsolt Felföldi: harder for them to approach, but, yeah, at a certain point, it would be…

17
00:04:56.970 --> 00:05:02.870
Zsolt Felföldi: nice to get their attention, too. But, yeah, so right now, I'm mostly.

18
00:05:02.870 --> 00:05:03.669
Tamaghna Choudhuri: Yeah, discussing that.

19
00:05:03.670 --> 00:05:10.089
Zsolt Felföldi: testing with, like, core devs, because, yeah, I just want to get the EIP in. Oh, Kev is also here, hi.

20
00:05:10.310 --> 00:05:12.299
Zsolt Felföldi: It's great that you could come.

21
00:05:14.040 --> 00:05:15.070
Zsolt Felföldi: So… Cool.

22
00:05:15.660 --> 00:05:16.540
Zsolt Felföldi: Oh.

23
00:05:17.650 --> 00:05:24.800
Zsolt Felföldi: Alright, so, I think… Yeah, now it's 5 minutes plus 4…

24
00:05:25.060 --> 00:05:27.799
Zsolt Felföldi: Or so, maybe we can even…

25
00:05:29.520 --> 00:05:34.309
Zsolt Felföldi: start, and lah, yeah. Maybe someone else will join you later, but…

26
00:05:34.450 --> 00:05:44.950
Zsolt Felföldi: I think, I think, I think we can, we can start this now. So, by the way, Kev, you weren't here at the previous one, two weeks ago, right?

27
00:05:48.190 --> 00:05:48.870
Kevaundray Wedderburn: Yeah, exactly.

28
00:05:48.870 --> 00:05:58.850
Zsolt Felföldi: because of the context, yeah, yeah. Okay, so, okay, just, then I want to do, like, a really quick recap, of…

29
00:05:59.180 --> 00:06:10.209
Zsolt Felföldi: what… yeah, just to give some context, so first I will turn on… screen share… And… Says Desktop 1.

30
00:06:10.590 --> 00:06:11.630
Zsolt Felföldi: Okay.

31
00:06:13.800 --> 00:06:16.800
Zsolt Felföldi: So, you should be able to see my screen now.

32
00:06:21.580 --> 00:06:28.170
Zsolt Felföldi: So, yeah, I will just use my, my, my Eat Border slides now.

33
00:06:28.490 --> 00:06:33.560
Zsolt Felföldi: So, can you see? See my screen?

34
00:06:34.610 --> 00:06:35.210
Kevaundray Wedderburn: Yeah.

35
00:06:36.230 --> 00:06:37.309
Zsolt Felföldi: Alright, alright.

36
00:06:37.370 --> 00:06:42.850
Zsolt Felföldi: So, so… This, this, so there's this, there's this,

37
00:06:42.850 --> 00:07:00.800
Zsolt Felföldi: lead us to design this 7745B, which maybe will get a separate EIP number at a certain point, but not yet. Anyway, so this is, this is, this is, this is currently probably the best approach, and let me just quickly…

38
00:07:01.690 --> 00:07:07.350
Zsolt Felföldi: show what it's about. So, basically,

39
00:07:07.350 --> 00:07:24.009
Zsolt Felföldi: there are these, so, so the way it works… let's… maybe I will go for… for this, this, this, this figure first. So it generates, search tables, and yeah, we can go… I will go into how they work exactly, but, right now it's, it's,

40
00:07:24.110 --> 00:07:41.209
Zsolt Felföldi: It's not even very important, so the… so the interesting thing is that, so this… this… this latest version of the log index, it, it, the way it works is that, it generates, so-called index tables, and index tables contain the events of

41
00:07:41.210 --> 00:07:44.380
Zsolt Felföldi: Like, either a single block or a…

42
00:07:44.810 --> 00:07:52.020
Zsolt Felföldi: Certain number of blocks, and and… and the way they are generated is that,

43
00:07:52.130 --> 00:08:05.160
Zsolt Felföldi: with the head block, with the current currency process block, a new index table, a single block index table is generated, and, and later, these tables.

44
00:08:05.620 --> 00:08:10.489
Zsolt Felföldi: Are merged together into bigger tables, so that's there.

45
00:08:10.580 --> 00:08:23.639
Zsolt Felföldi: form, like, a bigger search tree that is more efficient, and… and… and so the thing is that only… so there's… there's a single block table that's generated, like, during block… block processing, like, synchronously, and then…

46
00:08:23.640 --> 00:08:32.209
Zsolt Felföldi: later, bigger tables. So in this design, we merged, like, four single block tables into

47
00:08:32.260 --> 00:08:41.210
Zsolt Felföldi: like, this second row at the… from the bottom, these tables are… represent, like, four blocks, and then there's another,

48
00:08:41.350 --> 00:08:49.370
Zsolt Felföldi: Chain of tables that is… is… each table, represents 16 blocks and then 64 blocks.

49
00:08:49.530 --> 00:09:04.080
Zsolt Felföldi: And so these higher level tables, they are generated asynchronously, so they can be processed when there's no block processing happening, and probably this is the smallest amount of burden we can put on the protocol.

50
00:09:04.320 --> 00:09:16.060
Zsolt Felföldi: And, and… and so this is, this is, this is, this is how this index is generated, like, from a high-level overview, in the consensus. And,

51
00:09:16.500 --> 00:09:18.169
Zsolt Felföldi: And, and

52
00:09:18.610 --> 00:09:31.189
Zsolt Felföldi: Yeah, so… so the way… let me just quickly… so this is… this is one of the tables, this is how it looks, and what it has is, basically, it's an order list of the events, and it's… it's three hashed.

53
00:09:31.420 --> 00:09:39.529
Zsolt Felföldi: So it can be at the events of single block, or in this case, this is the events of multiple blocks.

54
00:09:40.020 --> 00:09:55.589
Zsolt Felföldi: And they are ordered by content first, and then inclusion position. So, there's also an example of how we use it for prEOFs. Like, the simplest example is, like, an exclusion prEOF.

55
00:09:55.930 --> 00:09:56.840
Zsolt Felföldi: So…

56
00:09:57.010 --> 00:10:09.819
Zsolt Felföldi: For example, if we want to look up an entry, which is, in this example, a non-existent transaction hash, then we look into this table, which is… either we can do a binary search, or

57
00:10:09.910 --> 00:10:26.880
Zsolt Felföldi: if it's locally stored more efficiently, it can be a more efficient search tree. Anyway, so we look up the position where this entry should be, if it's present, and then if we find it's not present, like in this case, then we do a merger prEOF that proves the entries

58
00:10:26.970 --> 00:10:35.320
Zsolt Felföldi: Before and after the non-existent event, so… and we know that this list is ordered, so this proves that this event doesn't exist.

59
00:10:35.640 --> 00:10:51.420
Zsolt Felföldi: or there's an… I have another example, yeah, which is a bit more complex, because it's… it's a log pattern search, and yeah, I don't want to spend a lot of time with this now, but for example, here, at this, at the… at the bottom.

60
00:10:51.530 --> 00:10:58.260
Zsolt Felföldi: There's these four red lines, these are the proven entries, and we, for example, if we want to prove

61
00:10:58.430 --> 00:11:16.369
Zsolt Felföldi: all the instances where there is this topic 1 equals a certain, value, like this is the sender address of, of a USDT transfer, and the sender is called Bob, and we find the two occurrences of this

62
00:11:16.550 --> 00:11:33.969
Zsolt Felföldi: topic, and then… so the prEOF also goes similarly, so we prove the actual matches, occurrences, and we prove the two adjacent entries to… in order to prove that there's no more matches. So this is… this is how these tables work, and

63
00:11:33.970 --> 00:11:43.279
Zsolt Felföldi: And I already implemented these tables in GoEthereum, and they are super fast to search, and yeah, so, this could be very nice,

64
00:11:44.550 --> 00:12:01.400
Zsolt Felföldi: But the thing is that, there's a reason, so in this drawing, this is… so this is, this is, this is, what I… I would, want to, put in the protocol. So, so in the, in the, in the, in the block headers, basically, I would,

65
00:12:01.400 --> 00:12:11.090
Zsolt Felföldi: Hash in a chain of single block tables, four block tables, and up to 64 block tables, but not bigger ones, because

66
00:12:11.200 --> 00:12:20.540
Zsolt Felföldi: Because… because with this design, it's, it's guaranteed that the block builders and validators only need the last

67
00:12:21.130 --> 00:12:34.979
Zsolt Felföldi: 80-something, 80 few blocks to generate or verify new blocks, so… so it's, it's, it's manageable, but, but, I don't want all the… so, so, so, so that would be a…

68
00:12:34.980 --> 00:12:42.870
Zsolt Felföldi: too high demand on every participant of the protocol to… for them to process tables of, I don't know.

69
00:12:42.930 --> 00:12:59.509
Zsolt Felföldi: hundreds of thousands of blocks, and yeah, so… so this, this, this, this, so bigger tables than 64 blocks should be somehow, proven off-chain. And so that's, that's the basic idea, and that's, why I want to use ZK prEOFs now.

70
00:12:59.870 --> 00:13:04.720
Zsolt Felföldi: And, yeah, so there's this…

71
00:13:05.040 --> 00:13:17.949
Zsolt Felföldi: I even made, like, one of the slides where I, just explained why I want to use both in-protocol processing and ZK prEOFs, but I think it's, like, kind of obvious.

72
00:13:18.100 --> 00:13:20.679
Zsolt Felföldi: But so, so,

73
00:13:20.690 --> 00:13:40.850
Zsolt Felföldi: with the… for the four latest blocks, it's very good to process the things in protocol, because otherwise anything between the latest generated ZK prEOF and the current head, all the search would be unindexed, and unindexed search is extremely expensive.

74
00:13:41.080 --> 00:13:47.390
Zsolt Felföldi: And so, yeah, it's… I think this is… this is… this could be a really good balance to just,

75
00:13:47.800 --> 00:13:48.470
Zsolt Felföldi: Like…

76
00:13:50.120 --> 00:13:57.189
Zsolt Felföldi: do a little bit of processing in protocol, and basically use the same data structures, just prove them, prove them with ZK prEOFs.

77
00:13:57.570 --> 00:14:03.630
Zsolt Felföldi: for, for, like, bigger, bigger tables, and…

78
00:14:04.190 --> 00:14:10.550
Zsolt Felföldi: And, in the end, we would have kind of, yeah, so this, this is this…

79
00:14:11.730 --> 00:14:29.459
Zsolt Felföldi: drawing shows, like, so this is how these index tables would cover the whole chain history. So we would have, like, small tables, bigger tables, and for the order history, even bigger tables, and we could basically cover the entire chain history with a logarithmic number of tables.

80
00:14:29.800 --> 00:14:30.750
Zsolt Felföldi: So…

81
00:14:31.050 --> 00:14:47.600
Zsolt Felföldi: So, an inclusion or exclusion prEOF of an event, or combination of events, that would be roughly log squared, because there's a logarithmic number of tables, and the Merck prEOF in a table is also logarithmic.

82
00:14:47.600 --> 00:14:59.160
Zsolt Felföldi: And I calculated that with the current mainnet data, a full history lookup for a single event would be something like 40 kilobytes, which is…

83
00:14:59.300 --> 00:15:04.090
Zsolt Felföldi: very good. It's just… so the only, only,

84
00:15:04.570 --> 00:15:22.129
Zsolt Felföldi: question that we still have to figure out is whether we can really prove these tables with ZK prEOFs, and this is where I will certainly need some help, but I tried to already kind of imagine how this would work.

85
00:15:23.430 --> 00:15:32.500
Zsolt Felföldi: And let me just open… now, these are not really good slides, this is just some drawings I did for today, and… oh, yeah.

86
00:15:33.290 --> 00:15:43.589
Zsolt Felföldi: Anyway, yeah. So, wait… Yeah, that… okay, okay, this is the right one. So basically,

87
00:15:44.110 --> 00:15:48.349
Zsolt Felföldi: This, this, this first drawing here, these,

88
00:15:48.450 --> 00:16:02.459
Zsolt Felföldi: these, these, these numbered little boxes, these are, like, simplified representations of the index entries, so the index entries, they have, like, multiple fields, but still, they are basically 64 byte,

89
00:16:02.780 --> 00:16:18.370
Zsolt Felföldi: binary entries, and they are ordered lexicographically. So, like, for simplification, now I just use two-digit numbers, but 64-byte entries can be ordered the same way. So… so this is how,

90
00:16:19.380 --> 00:16:30.979
Zsolt Felföldi: Merging two tables works, so these numbers are the same here and here, and at the bottom row, they are merged into single

91
00:16:31.520 --> 00:16:38.700
Zsolt Felföldi: Single, single, singles table, and and what I want to achieve is that,

92
00:16:39.270 --> 00:16:50.209
Zsolt Felföldi: So these tables can be, very large after time, so we… I think… I think right now we have something… so mainnet has something like,

93
00:16:50.380 --> 00:16:58.960
Zsolt Felföldi: 20-something billion entries. And, these… these don't all have to go into a single table, but,

94
00:16:59.090 --> 00:17:04.800
Zsolt Felföldi: But, but, but at the, like, the older history would certainly, beef.

95
00:17:05.099 --> 00:17:06.070
Zsolt Felföldi: built off.

96
00:17:06.150 --> 00:17:16.059
Zsolt Felföldi: like, billions of entries, so… so, probably this is not provable with a single execution trace. That would be too expensive.

97
00:17:16.060 --> 00:17:26.560
Zsolt Felföldi: So I wanted to design this thing in a way that, that even a single table can be proven recursively, slice by slice.

98
00:17:26.770 --> 00:17:35.019
Zsolt Felföldi: And, so this… this is what this example is… tries to show. So, basically, what we… the way…

99
00:17:35.160 --> 00:17:54.259
Zsolt Felföldi: I want to generate a prEOF is… so locally, I can… the prover can generate the tables, so it already does have the smaller tables that it's merging together, and it already has the bigger table, and it can already calculated the table root, it just wants to prove that it's the correct table root.

100
00:17:54.430 --> 00:18:05.780
Zsolt Felföldi: And and and in this example, these green… green boxes, this is… so this is the section that the prover wants to prove that it is correct. So…

101
00:18:06.010 --> 00:18:23.599
Zsolt Felföldi: So, basically, for… for this, what it needs is… is to… to prove the, from the target table, it has to prove this… this section of entries with a Mercer prEOF, so that would be a witness for the, for, for the private input of the CK prEOF.

102
00:18:23.710 --> 00:18:35.499
Zsolt Felföldi: And, it also has to prove the corresponding, parts from the… from the two, merged tables, smaller, tables that are being merged. And,

103
00:18:35.640 --> 00:18:47.840
Zsolt Felföldi: Also, like, in this example, this first entry is 33, so in the left small table, we do have the 33 entry, but in the other one,

104
00:18:48.190 --> 00:18:58.119
Zsolt Felföldi: We also have to, prove, like, one entry before that, in order to prove that before 36, there's no 34, or something like that.

105
00:18:58.210 --> 00:19:18.110
Zsolt Felföldi: And also, at the end, like, the last entry we want to prove is 48, and in the left, smaller table, like, upper left table, we also have to prove the next entry. But basically, we only need to prove, at most, one extra entry at the

106
00:19:18.640 --> 00:19:26.659
Zsolt Felföldi: Each end of the proven section. So, basically, we… we… we have to… have to provide a,

107
00:19:27.270 --> 00:19:34.620
Zsolt Felföldi: Merkel prEOF of, of, of, of the merge sections, and… and that's…

108
00:19:35.620 --> 00:19:40.730
Zsolt Felföldi: So, so that's how we would prove a single slice.

109
00:19:41.180 --> 00:19:49.959
Zsolt Felföldi: And, but also, we somehow have to, like, recursively merge these things together, and not just single tables.

110
00:19:50.130 --> 00:19:57.029
Zsolt Felföldi: So, like, this is… this is kind of similar to… what I, yeah…

111
00:19:57.980 --> 00:20:17.410
Zsolt Felföldi: ruin my, my, my, my presentation slides. So, in this case, we have, we have, we have, so in this drawing, the smallest tables, these, these little blue rectangles are, are the 64 block tables that are, generated in protocol, and, basically.

112
00:20:17.410 --> 00:20:21.990
Zsolt Felföldi: We want to merge these further together, so…

113
00:20:22.360 --> 00:20:34.699
Zsolt Felföldi: somehow I would like to construct the prEOF in a way that, once… so, for example, once we have, like, this, so this is… this… this prEOF somehow already proves that, that,

114
00:20:35.010 --> 00:20:47.200
Zsolt Felföldi: These are the, the, like, we have, we have, we have, we have the 128 block, tables, and 256 block tables, and so on, and… and this is, this is… these are all…

115
00:20:48.570 --> 00:21:05.039
Zsolt Felföldi: basically chain hashed together, so they can be proven. So, so this, this would be pretty much a similar, similar structure than what the consensus has, it's just, yeah, so this is, this would be the… the public part of the prEOF, that the prEOF actually proves, that,

116
00:21:05.440 --> 00:21:23.030
Zsolt Felföldi: And the reason the button tables are different, they are called the reference table chain, that's why they are blue, is that, in every prEOF, so this would be the assumption, and the prEOF would prove that if these tables

117
00:21:23.340 --> 00:21:29.649
Zsolt Felföldi: are… have the certain hash, which we can verify from consensus, then the bigger tables.

118
00:21:29.920 --> 00:21:31.750
Zsolt Felföldi: R, this, and this, and this.

119
00:21:31.940 --> 00:21:36.570
Zsolt Felföldi: the merged version of the same thing. So this is how it would look.

120
00:21:36.670 --> 00:21:41.580
Zsolt Felföldi: And also… Like, this would be a partial prEOF.

121
00:21:41.820 --> 00:21:49.300
Zsolt Felföldi: So when we are merging a bigger table, then we should somehow be able to also represent when

122
00:21:50.790 --> 00:21:57.510
Zsolt Felföldi: So, in this case, the reference table chain would be probably, Certainly. Even, like…

123
00:21:57.650 --> 00:22:01.329
Kevaundray Wedderburn: Yes? Sorry, I think I missed something on the previous slide.

124
00:22:02.350 --> 00:22:03.650
Kevaundray Wedderburn: Yes?

125
00:22:05.990 --> 00:22:07.790
Kevaundray Wedderburn: So…

126
00:22:08.590 --> 00:22:17.710
Kevaundray Wedderburn: Yeah, the second and third row, so the block count is 0x200, and the last blocks… the last block is 0xFFF.

127
00:22:19.060 --> 00:22:27.280
Kevaundray Wedderburn: And the block count is 0x800, and the last block was 0XFFF. I don't understand why we have these two…

128
00:22:28.580 --> 00:22:37.740
Zsolt Felföldi: Okay, oh, yeah, yeah, yeah, maybe, maybe, yeah, I wrote that those for a reason, so maybe I should also, yeah, explain those. So, yeah,

129
00:22:38.860 --> 00:22:40.929
Zsolt Felföldi: In this case,

130
00:22:42.480 --> 00:22:58.070
Zsolt Felföldi: we… I… I… so we should also store in the prEOF that, that, what is the last block, and… so basically, basically, the block count is… I used hacks so that, yeah, it's just easier to see how it doubles and everything, but,

131
00:22:58.410 --> 00:23:16.979
Zsolt Felföldi: Yeah, maybe, maybe, yeah, I messed up one of the block counts, so in the second row, the block counts should be 0x400, but anyway, so it should double from, like, like, 40, 80, 100, 200, 400, 800 as we go upwards. So, yeah, they, they are, like, always double in size.

132
00:23:17.090 --> 00:23:21.580
Zsolt Felföldi: And, well, the last block is… Now…

133
00:23:21.980 --> 00:23:25.569
Zsolt Felföldi: it… I mean, the whole indexing starts at a certain block.

134
00:23:25.890 --> 00:23:38.420
Zsolt Felföldi: probably, like, when, when, like, the EIP that generates the 64 block tables gets activated, then we can just call that,

135
00:23:38.600 --> 00:23:42.990
Zsolt Felföldi: So, so that's, that's, that's, that's, that's where, where, where the indexing

136
00:23:53.650 --> 00:24:03.820
Zsolt Felföldi: with the IP7708, which also generates the logs for ET transfers and everything. So, yeah, so that's going to be a whole other story, and for…

137
00:24:04.040 --> 00:24:15.909
Zsolt Felföldi: simplicity… In this case, we only care about, like, the post-EIP activation chain, and

138
00:24:16.210 --> 00:24:25.689
Zsolt Felföldi: And… and… but here, I just assumed that, that, the indexing starts at block 0. So, for example, like…

139
00:24:26.590 --> 00:24:37.300
Zsolt Felföldi: Yeah, like, at the highest table, which is… the block count is 800, so it starts from 0, then the last block is 7FF.

140
00:24:38.010 --> 00:24:53.169
Zsolt Felföldi: Logically, and also, in, below that, yeah, the block count should be 400 in the second row, and 4 times 400 is… is 1000, but yeah, so the last block is 1000 minus 1, so FFF.

141
00:24:53.670 --> 00:24:56.120
Zsolt Felföldi: And, yeah, this is just…

142
00:24:56.550 --> 00:25:14.129
Zsolt Felföldi: Just to… so, and in the consensus, there's, so in the protocol for those four table chains, we always exactly know which is the last one, because there's… there are protocol rules to when to

143
00:25:14.750 --> 00:25:17.450
Zsolt Felföldi: Add the new table hashes to each chain.

144
00:25:17.960 --> 00:25:24.490
Zsolt Felföldi: But, in case of, like, these higher tables and ZK prEOFs,

145
00:25:24.590 --> 00:25:40.270
Zsolt Felföldi: we should be a bit more flexible, because, yeah, it… all of this happens asynchronously, so… yeah, we should just store it also in the proven data structure, what is the last block? And also.

146
00:25:40.500 --> 00:25:44.330
Zsolt Felföldi: Yeah, also, just probably store the block count too, because…

147
00:25:44.500 --> 00:25:55.169
Zsolt Felföldi: yeah, we… we should not set it in stone how many chains we should have. We could be adaptive, and… yeah, anyway, so this is…

148
00:25:55.440 --> 00:26:01.070
Zsolt Felföldi: This is why we have block count and last block for every chain of index tables.

149
00:26:03.090 --> 00:26:08.749
Zsolt Felföldi: Yeah, so, so, so the… And the way these new tables would be constructed.

150
00:26:08.840 --> 00:26:27.499
Zsolt Felföldi: So this is this, this, this last slide. So, so first, we would, we would start to merge together two tables. So, one of them is, like, I just switched back, so this is the second row, these, 4 times 400 block.

151
00:26:27.760 --> 00:26:38.600
Zsolt Felföldi: Tables, and here, they are the blue ones, because they are used as reference, because the 800 block table is being merged from two 400 block tables.

152
00:26:38.940 --> 00:26:46.420
Zsolt Felföldi: And… and only a certain section is being merged, but so this is… this is something that also has to be

153
00:26:46.610 --> 00:26:50.439
Zsolt Felföldi: Represented in the… in the… in the prEOF.

154
00:26:50.910 --> 00:27:05.269
Zsolt Felföldi: And, and in this case, I don't want to, enforce to prove the entire state of the other table chains, because recursively proving… so recursively verifying,

155
00:27:05.270 --> 00:27:13.110
Zsolt Felföldi: An existing prEOF also has a significant cost, so… why? So it's probably better to not…

156
00:27:13.290 --> 00:27:32.080
Zsolt Felföldi: start with merging it into every, every, every small prEOF, every partial prEOF, but first do this partial prEOFs, merge them together, and when we have a full table, then we can, merge them to the big, big thing. But I want to… so this is this example.

157
00:27:32.360 --> 00:27:43.790
Zsolt Felföldi: I just wanted to show that the data structure can be… so the way I specified it, and I will also show, like, some drafted specifications soon.

158
00:27:44.110 --> 00:27:51.070
Zsolt Felföldi: So this is, like, it can show… it can store any number of food tables, and also.

159
00:27:51.190 --> 00:27:56.190
Zsolt Felföldi: like, it can, it can, it can also,

160
00:27:57.060 --> 00:28:15.350
Zsolt Felföldi: partially proven tables, and they can be merged in any combination. Even multiple sets of food table chains can be merged together. If in one prEOF one table chain is proven further, and in another prEOF another table chain is proven.

161
00:28:15.380 --> 00:28:24.269
Zsolt Felföldi: Further, and this is because… so this, so this prEOF, so generating these prEOFs for the large blocks, this will be probably

162
00:28:25.060 --> 00:28:31.980
Zsolt Felföldi: big effort for one prover, but, but, but, for many provers. So, so I, I wanted to…

163
00:28:32.260 --> 00:28:37.879
Zsolt Felföldi: actually what I wanted to achieve is that, even… the… so the…

164
00:28:38.170 --> 00:28:46.860
Zsolt Felföldi: the work… all these works can be merged together, even if we don't have absolutely perfect coordination. So, yeah.

165
00:28:47.050 --> 00:28:51.859
Zsolt Felföldi: and… and this is pretty much what I want to achieve.

166
00:28:52.250 --> 00:28:55.100
Zsolt Felföldi: And also, the way I started to…

167
00:28:55.600 --> 00:28:58.869
Zsolt Felföldi: specify this. I, I really, really didn't…

168
00:28:59.240 --> 00:29:04.180
Zsolt Felföldi: So this is… this is really… just should be considered a draft, but

169
00:29:04.360 --> 00:29:20.530
Zsolt Felföldi: here it is. So I just started to write these type definitions and verifier functions in Go, because, yeah, I can… I'm familiar with Go, probably we will have to… I will have to rewrite this in Rust.

170
00:29:20.980 --> 00:29:31.029
Zsolt Felföldi: Or, yeah, yeah, probably Rust, I guess, but, the way I imagine this, so this is, like, in my table-prEOF branch.

171
00:29:31.260 --> 00:29:38.230
Zsolt Felföldi: In gologin deux table prEOF.go, it doesn't really do anything, this is really, really just, just some…

172
00:29:38.540 --> 00:29:41.920
Zsolt Felföldi: code, go-code-shaped specification.

173
00:29:43.200 --> 00:29:44.790
Zsolt Felföldi: So, the table prEOF.

174
00:29:45.250 --> 00:29:57.510
Zsolt Felföldi: We consist of a public and private part, and so the public part, the thing that is being proven, is a set of, or list of table chains.

175
00:29:57.510 --> 00:30:09.379
Zsolt Felföldi: And the table chains are represented by the head, so as I've shown in the drawing, block count, last block, and the head hash. So these table chains are hashed in a way that each table has a table root.

176
00:30:09.380 --> 00:30:19.329
Zsolt Felföldi: which is the Mercker root of that list of entries, and, and the tables are chain hashed, so they had…

177
00:30:19.450 --> 00:30:27.700
Zsolt Felföldi: previous head hash is hashed together with the new table root, and that's the new table chain add hash. So, yeah, that's…

178
00:30:28.310 --> 00:30:42.210
Zsolt Felföldi: That's how I imagine this. And so, yeah, we do have a list of… list of completely rendered and proven tables, and we can also… and or we can also include partial tables.

179
00:30:42.450 --> 00:31:02.329
Zsolt Felföldi: Yeah, and in this table chains list, the first one is always the reference, so that's also a rule, because we can only merge upwards, so yeah, it's obvious, and we always need one reference, so… so table chain 0 is always the reference, and even if we are just merging partial tables, we do have, like, the one reference chain.

180
00:31:02.570 --> 00:31:17.849
Zsolt Felföldi: And the partial tables are, yeah, they also have block count and last block, and they already have the table root, because the prover already knows the table root in advance, it's just… it's, like, partially proven.

181
00:31:18.050 --> 00:31:23.540
Zsolt Felföldi: It also, yeah, has the full entry count of the table.

182
00:31:23.750 --> 00:31:29.439
Zsolt Felföldi: And, this, this, these proven ranges, this range set, it's basically

183
00:31:29.880 --> 00:31:43.459
Zsolt Felföldi: a subset of 0 to entry count minus 1. It can… can be, like, a continuous range, or… or multiple continuous ranges, but yeah, it's… it's… it's just a subset.

184
00:31:44.290 --> 00:31:48.380
Zsolt Felföldi: of, of the… Proven entries of the table.

185
00:31:48.670 --> 00:31:57.319
Zsolt Felföldi: So this is basically what I want to prove, and then this is the private part, like, the witness is how we prove it.

186
00:31:57.690 --> 00:32:04.130
Zsolt Felföldi: So, they would conti- Optionally, they could contain,

187
00:32:04.350 --> 00:32:08.129
Zsolt Felföldi: Recursive prEOFs, which would be the same type of prEOF.

188
00:32:08.320 --> 00:32:09.840
Zsolt Felföldi: just… Zip.

189
00:32:10.500 --> 00:32:13.200
Zsolt Felföldi: Proven stuff is being merged together.

190
00:32:14.420 --> 00:32:26.859
Zsolt Felföldi: Well, there's this stable root prEOFs that's just a technical thing, so… because the public-public part only proves the chain head, and for example, for merging together.

191
00:32:26.860 --> 00:32:36.030
Zsolt Felföldi: Multiple tables, we do need the individual… last few individual table roots, so these table root prEOFs can prove the last few table roots.

192
00:32:36.030 --> 00:32:38.150
Zsolt Felföldi: Of any of the table chains.

193
00:32:38.400 --> 00:32:41.879
Zsolt Felföldi: And there's the merge prEOFs, which is the actual thing.

194
00:32:42.090 --> 00:32:49.889
Zsolt Felföldi: actual, actual merging of, of table sections, and yeah, let me just scroll down a bit.

195
00:32:49.980 --> 00:33:02.630
Zsolt Felföldi: So yeah, the entry is just defined as a 64 byte, so here in this miracle prEOF, we really don't need to care about the internal structure of the entries, because they are just simple lexicographical ordering.

196
00:33:02.820 --> 00:33:06.130
Zsolt Felföldi: And, where's the merge?

197
00:33:06.560 --> 00:33:08.170
Zsolt Felföldi: Oof, yeah.

198
00:33:08.630 --> 00:33:10.320
Zsolt Felföldi: Table Merced prEOF.

199
00:33:11.780 --> 00:33:13.210
Zsolt Felföldi: Yeah, here's it.

200
00:33:13.440 --> 00:33:14.660
Zsolt Felföldi: Oh, oh yeah.

201
00:33:15.660 --> 00:33:23.970
Zsolt Felföldi: So, yeah, the table merge prEOF is… is, consists of table range prEOFs, and the table range prEOF is…

202
00:33:24.310 --> 00:33:42.269
Zsolt Felföldi: yeah, basically there's the entry count, and the first entry, and the number of entries fully stored, and the left and right side Mercer branches. So, yeah, it can be… so this can be verified against the table root.

203
00:33:42.450 --> 00:33:47.720
Zsolt Felföldi: And, yeah, for the merge prEOFs, we have multiple ones for the input.

204
00:33:47.890 --> 00:33:51.949
Zsolt Felföldi: The smallest tables being merged, and one for the output.

205
00:33:52.460 --> 00:33:54.000
Zsolt Felföldi: is being proven.

206
00:33:54.390 --> 00:34:08.130
Zsolt Felföldi: And, yeah, so this is pretty much, I, yeah, there's also some code of how it works, and I don't really want to just go into those now, I even have to work a little bit on documenting those, but yeah.

207
00:34:08.270 --> 00:34:14.519
Zsolt Felföldi: So… so this is… this is my idea of how those prEOFs would work, and now I…

208
00:34:14.870 --> 00:34:28.400
Zsolt Felföldi: will just need some input on whether this whole idea is workable, could the prEOFs be implemented in this way, or am I just thinking something completely wrong?

209
00:34:33.030 --> 00:34:33.900
Zsolt Felföldi: So…

210
00:34:35.969 --> 00:34:42.359
Kevaundray Wedderburn: Oops, sorry. Yeah, so I might need a bit more time to catch up on the general…

211
00:34:42.419 --> 00:34:58.529
Kevaundray Wedderburn: log index structure to see if anything's, fully changed from when I last looked at it. But from the ZK part, the prEOF that you mentioned, I think it all makes sense. The recursive prEOF part,

212
00:35:00.559 --> 00:35:01.239
Kevaundray Wedderburn: Hmm…

213
00:35:02.559 --> 00:35:19.349
Kevaundray Wedderburn: Yeah, I guess it's unclear if you do need it, to be honest. Depends on how big the input is, because ZKVMs also do a sort of recursive prEOF internally. If the thing being proven is, like, too big, it would, like, break it up internally.

214
00:35:19.499 --> 00:35:20.349
Kevaundray Wedderburn: Okay.

215
00:35:20.350 --> 00:35:28.790
Zsolt Felföldi: So how much is too big? Like, for example, if… so the inputs are, like, let's assume, at most, like,

216
00:35:29.780 --> 00:35:35.309
Zsolt Felföldi: Like, it could be, like, 100 gigabytes, so that's probably too big for a single prEOF.

217
00:35:35.650 --> 00:35:40.259
Kevaundray Wedderburn: Right, right. Yeah, I mean, too big hair just means,

218
00:35:40.610 --> 00:35:48.490
Kevaundray Wedderburn: how much your hardware can handle, essentially, because the circuit for ZKVMs has, like, a limit, let's just say…

219
00:35:48.680 --> 00:35:52.749
Kevaundray Wedderburn: 100 million cycles.

220
00:35:52.880 --> 00:36:07.769
Kevaundray Wedderburn: So you can always break down your prEOF into, like, chunks of a hundred… sorry, you can always break down your program into chunks of 100 million cycles, and it's just on, can the hardware do it, and can the hardware do it in a reasonable amount of time?

221
00:36:09.730 --> 00:36:23.060
Kevaundray Wedderburn: So I think it depends. There might be other memory limits that I can't remember for, like, certain ZKVMs, but I think in general, it's unclear if you do need the recursive prEOF part.

222
00:36:24.920 --> 00:36:42.490
Zsolt Felföldi: Well, so one reason I might need the recursive prEOF is that even if, if, if, if it… so maybe, maybe, maybe for most of the tables, proving one table maybe could be done in a single prEOF, but the thing is that, we have, like, this… let's just…

223
00:36:43.320 --> 00:36:54.989
Zsolt Felföldi: Yeah, somewhere. So, in the end, this is what I want to achieve. I want to… so I… I don't want, like, 30 prEOFs for all the different chains, so there's going to be, like, lots of…

224
00:36:54.990 --> 00:37:07.310
Zsolt Felföldi: these chains, and they will all keep changing, and and I don't want to redo all the work, like, re-prEOF everything every time, so every time I will… I just want to do a prEOF of

225
00:37:07.400 --> 00:37:25.169
Zsolt Felföldi: of merging two head tables into a bigger one, and two head tables into a bigger one at a higher level, and… and… and… and I want to aggregate this knowledge. So that's the way I understand it, so that's done with recursive prEOFs.

226
00:37:25.580 --> 00:37:33.280
Kevaundray Wedderburn: Yeah, exactly. Yeah, I mean, if that's the constraint that you have, then I think the recursive prEOF approach works.

227
00:37:33.280 --> 00:37:44.570
Zsolt Felföldi: Yeah, by the way, is there any difficulty with the recursive prEOF? So, is it… is it does… does it… is it, like, an extra thing that needs some… some special tools, or… I don't know.

228
00:37:45.970 --> 00:37:53.950
Kevaundray Wedderburn: Not really, some teams have implemented it. I'm not sure if every, team

229
00:37:54.570 --> 00:38:09.859
Kevaundray Wedderburn: has implemented it and applied… and gives you an API for it, because you need recursive prEOFs, but you also need to be able to access it in the Rust or Go program as well. Like, you need to have, like, a verify prEOF method.

230
00:38:10.170 --> 00:38:25.939
Kevaundray Wedderburn: And I'm not super sure that everyone exposes it. Everyone ha- everyone roughly has it because of the… the idea I talked about where you need to, like, chunk, the program into, like, 100 million cycles, but this is an internal thing, so,

231
00:38:26.100 --> 00:38:31.329
Kevaundray Wedderburn: I think, yeah, the only… Downside might be that not everyone has it.

232
00:38:31.580 --> 00:38:35.780
Kevaundray Wedderburn: oh, sorry, not everyone exposes it.

233
00:38:36.560 --> 00:38:44.120
Kevaundray Wedderburn: But… Yeah, I'm trying to think who doesn't, hmm…

234
00:38:46.480 --> 00:38:49.969
Kevaundray Wedderburn: Yeah, let me get back to you, I'd have to double-check.

235
00:38:50.380 --> 00:39:05.090
Zsolt Felföldi: Okay, yeah, yeah, this is not something, I expect you to answer right now, but, so I'm just, just, just wanted to present that these are my… this is my problem, and this… this is… this is what I will need some help with.

236
00:39:05.220 --> 00:39:15.909
Zsolt Felföldi: And yeah, so, or actually, you already sent me this, this, this example of this succinct, succinct, demo, and I did, like.

237
00:39:16.850 --> 00:39:21.140
Zsolt Felföldi: Try that, and ran the demo, and yeah, it looked really cool that it can…

238
00:39:21.500 --> 00:39:24.840
Zsolt Felföldi: prove the, like, Fibonacci numbers.

239
00:39:25.200 --> 00:39:32.219
Zsolt Felföldi: And I also tried to understand a little bit the other examples, and I… even there, I saw some… some recursive,

240
00:39:32.630 --> 00:39:34.150
Zsolt Felföldi: PrEOF examples.

241
00:39:34.290 --> 00:39:36.930
Zsolt Felföldi: So, I'm not sure, which

242
00:39:37.350 --> 00:39:42.219
Zsolt Felföldi: To… tool chain, and which technology would you recommend right now?

243
00:39:43.890 --> 00:39:50.680
Zsolt Felföldi: Or, or, or, or this is also something that… is, it's like… Depends.

244
00:39:51.500 --> 00:40:03.889
Kevaundray Wedderburn: Right. Yeah, for ZKVM, at least the optional prEOFs, or EIP8025, we have, like, a framework that we've applied on top of the ZKVMs.

245
00:40:04.140 --> 00:40:11.439
Kevaundray Wedderburn: Which means that you can sort of abstract away each, ZKVM, That you're dealing with?

246
00:40:11.610 --> 00:40:18.380
Kevaundray Wedderburn: So I can paste a link to that… Air…

247
00:40:18.700 --> 00:40:21.570
Kevaundray Wedderburn: In that sense, I think…

248
00:40:21.690 --> 00:40:29.699
Kevaundray Wedderburn: all of the technologies probably work as good. The only issue that you'd probably have is that most of them

249
00:40:29.830 --> 00:40:36.680
Kevaundray Wedderburn: work with, like, low-level languages, so Go might not be… a feasible…

250
00:40:37.300 --> 00:40:40.580
Kevaundray Wedderburn: Alternate feasible, language to…

251
00:40:40.580 --> 00:40:58.930
Zsolt Felföldi: yeah, it's not such a big problem, so right now, I kind of implemented this thing, and maybe I need to publish a little bit, but the whole thing is, like, for… with comments and everything, 400-something lines of pure code, so it shouldn't be very hard to implement it in any language, so that's not really a big constraint.

252
00:41:00.030 --> 00:41:00.550
Kevaundray Wedderburn: Okay.

253
00:41:01.520 --> 00:41:05.579
Kevaundray Wedderburn: And… just pasting it in the chat.

254
00:41:05.820 --> 00:41:08.329
Kevaundray Wedderburn: So this is what we use,

255
00:41:11.390 --> 00:41:13.350
Kevaundray Wedderburn: Just pasted it in the chat.

256
00:41:13.850 --> 00:41:14.800
Kevaundray Wedderburn: And…

257
00:41:14.800 --> 00:41:17.069
Zsolt Felföldi: Let's just allow the extract away.

258
00:41:22.200 --> 00:41:38.469
Kevaundray Wedderburn: Yeah, so, yeah, I mean, I don't suggest any particular toolchain at the moment. If you're, like, still experimenting and trying to check what works. I'd probably suggest to use this, or if you're familiar with Sysynct already, then maybe just continue using that, and then…

259
00:41:38.500 --> 00:41:44.519
Kevaundray Wedderburn: Once you want to productionize it, we can abstract away the succinct, particular details.

260
00:41:45.910 --> 00:41:53.270
Zsolt Felföldi: Yeah, actually, I'm not super familiar, I just, yeah, try the demo and try to just understand what I really need to…

261
00:41:54.130 --> 00:42:04.339
Zsolt Felföldi: Lou, but, yeah, so… And by the way, so, this is another thing I wanted to ask, is, so there's…

262
00:42:04.850 --> 00:42:12.839
Zsolt Felföldi: That sounds… one thing what I understood from Succinct was that, it can, generate, like,

263
00:42:13.320 --> 00:42:30.349
Zsolt Felföldi: like, big prEOF starks, which are, like, around a megabyte or something, so… so they are… they are kind of big, and for… and if you want to… if I want to, verify these prEOFs on-chain, which I don't necessarily want to do.

264
00:42:30.750 --> 00:42:40.769
Zsolt Felföldi: maybe… maybe the prEOFs can just be transmitted to the clients, and they can verify it themselves, so these prEOFs don't… I'm not sure if, it's worth,

265
00:42:40.770 --> 00:42:52.149
Zsolt Felföldi: verifying them on-chain, but there's an… there's an alternative, some other prEOF system, which is probably SNAC, if I understood correctly, which is, like, really small, like, hundreds of bytes.

266
00:42:52.150 --> 00:42:53.030
Zsolt Felföldi: So…

267
00:42:53.180 --> 00:43:04.399
Zsolt Felföldi: what is the main difference between these? Is it, like, quantum security, or… or why are these… why are they there, like, very large and smaller prEOFs… prEOF systems?

268
00:43:06.200 --> 00:43:23.060
Kevaundray Wedderburn: So, so yeah, the… yeah, as you notice, there's, like, a Stark proving system and a SNARC one. The Stark one basically has a log… it scales logarithmically in the complexity of the thing you're proving, roughly.

269
00:43:23.140 --> 00:43:34.279
Kevaundray Wedderburn: So it's about 1MB. We can probably get it down to 300 kilobytes or less, but it means prover time, it takes longer to prove the thing.

270
00:43:34.670 --> 00:43:42.680
Kevaundray Wedderburn: The benefit of this, stark prEOF is that it is post-quantum safe. It basically just relies on hashes.

271
00:43:43.290 --> 00:43:52.619
Kevaundray Wedderburn: the SNARC approach, which is a GROF16 or Plonk, their prEOF sizes are roughly constant.

272
00:43:52.830 --> 00:43:55.190
Kevaundray Wedderburn: So it's gonna be, like…

273
00:43:55.710 --> 00:44:03.280
Kevaundray Wedderburn: Maybe, like, 1 kilo… I can't remember GROF16, but, like, 1KB, or maybe even less, for Graph 16.

274
00:44:03.510 --> 00:44:13.799
Kevaundray Wedderburn: The annoyance with Graph 16 in particular is that it is circuit-specific, meaning you're gonna need to do a,

275
00:44:15.450 --> 00:44:25.589
Kevaundray Wedderburn: this thing called a trusted setup per circuit, so you probably just don't want to use it, but succinct probably has a Planck proving system somewhere.

276
00:44:25.630 --> 00:44:36.919
Kevaundray Wedderburn: And those prEOF sizes are a bit larger than graph 16, but you can think of them as also roughly constant. The disadvantage of this is just that it's not post-quantum.

277
00:44:39.730 --> 00:44:48.069
Kevaundray Wedderburn: I think it's the Ganark-based punk one. I can't remember the prEOF sizes for succinct, but yeah, the main disadvantage there is that it's not post-quantum.

278
00:44:48.340 --> 00:44:53.220
Kevaundray Wedderburn: I don't know, does that honestly?

279
00:44:53.220 --> 00:44:54.250
Zsolt Felföldi: Yeah, so…

280
00:44:54.670 --> 00:45:02.699
Zsolt Felföldi: Yeah, yeah, I think this is… this is… this is… well, mostly confirms what I understood from the documentations. Yeah, I just wanted to, like.

281
00:45:03.230 --> 00:45:20.209
Zsolt Felföldi: No, for sure that I understand correctly, and I assume that, for, like, the future plans, like, like for Lin Ethereum, I guess, the, the, the, the execution proves those would be quantum secure, starts, right?

282
00:45:21.490 --> 00:45:34.189
Kevaundray Wedderburn: Right, so, the plan is for them to be 300 kilobytes, initially, and then we're gonna go down to 128 kilobytes, and then that should be enough for the networking layer to handle.

283
00:45:36.150 --> 00:45:40.020
Zsolt Felföldi: Alright, yeah, but for my use case.

284
00:45:40.410 --> 00:45:50.660
Zsolt Felföldi: basically, these, these, these index tables, I mean, I mean, these, these index table prEOFs, if, if, if, if, like, every, I don't know.

285
00:45:50.790 --> 00:45:54.010
Zsolt Felföldi: 256 blocks, we would generate a new

286
00:45:54.640 --> 00:46:14.469
Zsolt Felföldi: table merge round, so… so roughly, like, even if… if… if someone is willing to generate, a new prEOF for, like, as frequently as it makes sense, that would be, like, one new prEOF per hour or something. So for… for… for someone, like, who…

287
00:46:14.870 --> 00:46:31.889
Zsolt Felföldi: for some client, it's… it's totally acceptable to just, download, even a several hundred kilobyte, stark, from the prover, like, every hour, if the… if there's a new prEOF. So, yeah, I think… I think,

288
00:46:32.030 --> 00:46:34.710
Zsolt Felföldi: For my use case, probably…

289
00:46:34.820 --> 00:46:40.589
Zsolt Felföldi: I can, I can, I can live with, with even, like, hundreds of kilobytes, or one megabyte,

290
00:46:41.520 --> 00:46:46.280
Zsolt Felföldi: PrEOFs, and they don't necessarily have to… Go and chain.

291
00:46:46.630 --> 00:46:59.340
Zsolt Felföldi: But… but if I want to do something on-chain, then… then I would have to… I mean, for some reason, I would have… I would want to verify a prEOF on-chain, that… that would have to be a SNAR, right?

292
00:46:59.650 --> 00:47:04.659
Zsolt Felföldi: So… so stocks are not possible to verify on-chain. That would be too expensive, right?

293
00:47:05.500 --> 00:47:16.229
Kevaundray Wedderburn: Yeah, currently it's pretty expensive, but, it's likely that if everyone moves to post-quantum, we're gonna have to put something… we're gonna have to change something to make it not as expensive.

294
00:47:16.980 --> 00:47:23.279
Kevaundray Wedderburn: I don't know what the cost is right now, I believe Starkware probably does it currently.

295
00:47:23.460 --> 00:47:26.719
Kevaundray Wedderburn: But I don't know how much they pay for their stock prEOF.

296
00:47:26.720 --> 00:47:37.830
Zsolt Felföldi: Well, but I think, by the way, I also do have this, this idea that, yeah, maybe, maybe I also will show you this, because…

297
00:47:38.000 --> 00:47:43.840
Zsolt Felföldi: Now that we are talking, this might be interesting for me. - wait.

298
00:47:44.070 --> 00:47:48.690
Zsolt Felföldi: Did I open… New ones, it's not what I wanted.

299
00:47:49.380 --> 00:47:52.740
Zsolt Felföldi: Okay, yeah, anyways, this is what I needed.

300
00:47:53.420 --> 00:48:02.999
Zsolt Felföldi: So… yeah, this is… so this is… this is just this drawing that I have, like, like, for one of my talks.

301
00:48:03.190 --> 00:48:10.049
Zsolt Felföldi: So, this, is something, the way I kind of, like, imagined… so this, this, this is, this is…

302
00:48:10.420 --> 00:48:26.110
Zsolt Felföldi: This is how maybe transaction, could work in the future. So, so Vitalik already, like, wrote in this account, initial account, account abstraction EIP draft.

303
00:48:26.180 --> 00:48:44.529
Zsolt Felföldi: that, that, certain pre-checks, like, like, like, like, authorization, signatures, witnesses, those could be, proven pre, with ZK, ZK prEOFs, before the, the transaction reaches, like, the, the mempool. So this…

304
00:48:44.540 --> 00:48:53.709
Zsolt Felföldi: This is something like, for example, if we add witnesses to transactions, then the provers could create transaction batches.

305
00:48:53.730 --> 00:48:59.160
Zsolt Felföldi: And, and, and, and basically, the witnesses wouldn't have to go into the…

306
00:48:59.310 --> 00:49:09.309
Zsolt Felföldi: into the chain, and also additional ZK prEOFs could be, like, recursively mashed into one prEOF, or a few prEOFs. So,

307
00:49:09.990 --> 00:49:16.499
Zsolt Felföldi: So, yeah, maybe, maybe it would be possible in the future to just…

308
00:49:16.830 --> 00:49:30.419
Zsolt Felföldi: So I think, I think, I somehow assumed that, even for, for, for, like, post-quantum signatures, so those would be bigger than elliptical signatures. Probably, we would do something like this, and in the end, we would…

309
00:49:30.530 --> 00:49:39.299
Zsolt Felföldi: Like, put, ZK prEOFs, like, in the… in the… in the input of the…

310
00:49:39.910 --> 00:49:46.330
Zsolt Felföldi: rock building, too. So, yeah, maybe, maybe then, then putting extra prEOFs.

311
00:49:47.600 --> 00:50:00.169
Zsolt Felföldi: So, so what I want to get at is that maybe if we can just verify, like, like, one or a few, starks, per block.

312
00:50:00.390 --> 00:50:08.780
Zsolt Felföldi: Then, basically, we can verify as many as we want, as long as some provers are capable of doing recursive prEOFs.

313
00:50:09.370 --> 00:50:13.059
Zsolt Felföldi: So, do you think, like, this is realistic?

314
00:50:15.650 --> 00:50:19.099
Kevaundray Wedderburn: I think some of it is a bit TBD.

315
00:50:21.040 --> 00:50:31.509
Kevaundray Wedderburn: So I can't say for a certain, right now. Though one question I do have is I don't understand what's happening with the first, prover column.

316
00:50:31.670 --> 00:50:42.770
Kevaundray Wedderburn: So they get multiple transactions with witnesses, and these witnesses prove that the transaction is valid, or…

317
00:50:43.850 --> 00:50:44.570
Kevaundray Wedderburn: Yeah, I guess.

318
00:50:44.570 --> 00:50:54.970
Zsolt Felföldi: Well, yeah, so, so this is this, yeah, I just really quickly jumped into this without context, but, what I wanted to,

319
00:50:55.890 --> 00:51:00.470
Zsolt Felföldi: One, prove with this, this, this drawing is that,

320
00:51:00.470 --> 00:51:18.369
Zsolt Felföldi: witnesses, like, if we add witnesses to transactions that… that are basically, so verifying the witness has basically one bit of output, like, is the witness correct, or… no, no, it's not true, because we also have to add water witness prEOFs, but basically, if we have a large witness of

321
00:51:18.810 --> 00:51:20.720
Zsolt Felföldi: Of, like, a state read.

322
00:51:20.900 --> 00:51:29.439
Zsolt Felföldi: Then, then we can… Verify that witness off-chain, and the witness doesn't have to go to the chain.

323
00:51:29.700 --> 00:51:48.940
Zsolt Felföldi: So that's what I wanted to prove here, and I… so the reason I wanted this is that, yeah, I… I also… this is another drawing where, so… so this… this is just a crazy idea of mine, that, with the new log index, but this is not something we should,

324
00:51:49.520 --> 00:51:54.169
Zsolt Felföldi: get a conclusion on now, it's just, just the way I imagine…

325
00:51:54.880 --> 00:52:01.689
Zsolt Felföldi: A possible future that, maybe we could also use… use the log index for, for,

326
00:52:01.960 --> 00:52:07.710
Zsolt Felföldi: for, like, contract logic, and it… I think it would have some advantages. One of them is that it's

327
00:52:08.260 --> 00:52:27.030
Zsolt Felföldi: my, according to my estimates, about 100 times cheaper to add an entry to the log index than to the state tree. So, yeah, so maybe, maybe for some applications, this would be viable, but the thing is that for the log index, the width size is not logarithmic, but log squared. So, yeah.

328
00:52:27.240 --> 00:52:45.100
Zsolt Felföldi: putting the… putting… putting log index, witnesses on-chain, is… would be probably expensive, but maybe if we can just do this, that, we, we, we, we take the… these witnesses.

329
00:52:45.230 --> 00:52:55.339
Zsolt Felföldi: And, I mean, like, this, this analog index widthness can be something like 50 or 100 kilobytes, so, like, like, kind of big. But, but if we just,

330
00:52:55.500 --> 00:53:03.710
Zsolt Felföldi: prove the… ZK approved the verification of these witnesses, then maybe they could be also proven on-chain. So yeah, this is… this is this…

331
00:53:04.000 --> 00:53:13.919
Zsolt Felföldi: This is something that, maybe, yeah, we can discuss at a later point, but, but this is just my latest idea of a future use case for the log index.

332
00:53:14.170 --> 00:53:19.740
Zsolt Felföldi: It's not something that I need now for the current use case. I'm just thinking about…

333
00:53:19.950 --> 00:53:25.230
Zsolt Felföldi: That, once we can afford to have, like, like,

334
00:53:25.600 --> 00:53:43.319
Zsolt Felföldi: one Stark, or a few Starks in a block, then we can have basically as many Starks and witnesses in a block as we want, and it will have a cost, prover cost, but it will not have an extra on-chain cost. So that's my assumption.

335
00:53:44.050 --> 00:53:46.519
Kevaundray Wedderburn: Do you think this can be true?

336
00:53:47.560 --> 00:53:50.069
Kevaundray Wedderburn: I think it can be true.

337
00:53:50.960 --> 00:53:56.110
Kevaundray Wedderburn: I probably need to think a bit more before I say anything, like, actually.

338
00:53:56.110 --> 00:53:56.949
Zsolt Felföldi: Yeah, yeah, alright.

339
00:53:56.950 --> 00:53:59.929
Kevaundray Wedderburn: In case I'm missing, some details here.

340
00:54:00.730 --> 00:54:01.400
Zsolt Felföldi: Yeah, yo.

341
00:54:02.040 --> 00:54:04.920
Zsolt Felföldi: Anyway, this is just, just something I wanted to…

342
00:54:05.510 --> 00:54:14.810
Zsolt Felföldi: Quickly show, but, anyways, if we know, yeah, we can just first focus on, on, on, on…

343
00:54:15.020 --> 00:54:18.050
Zsolt Felföldi: Finding a suitable,

344
00:54:18.190 --> 00:54:34.810
Zsolt Felföldi: prEOF system to just prove the table merging, so that's… that's the highest priority. And, so yeah, this is the link, and yeah, I will… I will definitely check this out, and yeah, I think, I think,

345
00:54:34.990 --> 00:54:45.859
Zsolt Felföldi: I know most of what I wanted to know. I have my answers. Actually, there's one more thing, there's one more thing, which will probably be a simpler one. So,

346
00:54:46.730 --> 00:54:52.519
Zsolt Felföldi: I… I was thinking about the hash function, because, so there's… there's…

347
00:54:52.960 --> 00:55:00.230
Zsolt Felföldi: the hash function I use for tree hashing the tables, because these tables, generating them and verifying them.

348
00:55:00.360 --> 00:55:03.589
Zsolt Felföldi: The cost of it is… will mostly be hashing cost.

349
00:55:03.700 --> 00:55:17.640
Zsolt Felföldi: And it would be nice to have a hash function that's reasonably efficient on a CPU, so, like, the table generation is also efficient, but also it's reasonably efficient for…

350
00:55:17.640 --> 00:55:25.100
Zsolt Felföldi: for the… for the… for the ZK prEOFs. Someone suggested Poseidon 2, which I never used, but…

351
00:55:25.240 --> 00:55:34.250
Zsolt Felföldi: I don't know… Well, maybe if you have a suggestion for hash function that… That would also be useful.

352
00:55:35.470 --> 00:55:43.209
Kevaundray Wedderburn: I would probably just start off with Ketchak, just because each ZKVM has,

353
00:55:43.670 --> 00:56:03.539
Kevaundray Wedderburn: like, accelerators for things like Ketchak, because when you prove an Ethereum block, you potentially do a bunch of Ketchaks already. So I'd probably start with Ketchak and see what the worst cases are, before, like, going to something a bit like Poseidon, which is, I guess, less,

354
00:56:05.360 --> 00:56:14.589
Kevaundray Wedderburn: It's… it's less, I guess, Lindy, or, like, Ketchak is pretty…

355
00:56:15.380 --> 00:56:21.970
Kevaundray Wedderburn: it's pretty a safe choice if you put it into, like, the consensus algorithm, or in Ethereum at the moment.

356
00:56:22.350 --> 00:56:28.990
Kevaundray Wedderburn: So I'd probably start with that and see what the worst cases are, and then if it's, like, too bad, then switch to something like Poseidon.

357
00:56:29.430 --> 00:56:35.279
Zsolt Felföldi: Okay, so, so, so, so, so Ketch might be reasonable, in a ZKVM, you say.

358
00:56:35.490 --> 00:56:37.610
Zsolt Felföldi: Okay. Also, by the way.

359
00:56:37.980 --> 00:56:38.710
Kevaundray Wedderburn: Yeah.

360
00:56:38.710 --> 00:56:49.770
Zsolt Felföldi: So right now, I started using, actually, not… so Catchback is SHA3, but I started using SHA2, which is, for CPU, it's, like.

361
00:56:49.850 --> 00:56:59.109
Zsolt Felföldi: 3-4 times faster. So, is it also efficient on the heavy AM, or catch-up is better?

362
00:56:59.950 --> 00:57:06.640
Kevaundray Wedderburn: I think it depends on how they've accelerated it, but usually they have SHA-2 accelerators as well.

363
00:57:07.850 --> 00:57:13.499
Zsolt Felföldi: Okay, so… so SHA-2 or SHA 3 might be a good choice to start with.

364
00:57:14.200 --> 00:57:18.960
Kevaundray Wedderburn: Right, but you need to sort of use the accelerator, version of it.

365
00:57:18.960 --> 00:57:24.479
Zsolt Felföldi: Okay, and what, yeah, so, so, so yeah, obviously, I, I don't…

366
00:57:24.780 --> 00:57:34.530
Zsolt Felföldi: you have to prove the execution trace of, like, the dump, implementation of the hash function. But, so how do these… how…

367
00:57:35.250 --> 00:57:44.810
Zsolt Felföldi: do these accelerators work? If I read this link, is in this framework, is there something for hash acceleration included?

368
00:57:45.620 --> 00:57:58.609
Kevaundray Wedderburn: In that link in particular, no, but roughly how they work is that you have, like, a particular circuit for Ketchak, so you implement catch-ac as a circuit.

369
00:58:00.020 --> 00:58:11.839
Kevaundray Wedderburn: And whenever the Rust program calls Ketchak, instead of calling your normal catch-acc dependency, you have a particular mechanism for calling this circuit instead.

370
00:58:12.250 --> 00:58:30.639
Kevaundray Wedderburn: so the naive way is to prove, like, the execution, all the, the naive dump of, like, Ketchak, which is, like, a bunch of RISC-V instructions, but the smart way is to call this accelerator, just like how CPUs have, SHA-2 accelerators, for example, or AES accelerators.

371
00:58:31.430 --> 00:58:45.369
Kevaundray Wedderburn: You just need to know how to call it, and at the moment, each ZKVM has a different calling mechanism, but we've just standardized it, so they should be implementing the standardization soon.

372
00:58:45.530 --> 00:58:52.339
Kevaundray Wedderburn: With the standardization, they're basic… you basically just need to call a C header, and then you're done.

373
00:58:56.040 --> 00:58:58.930
Kevaundray Wedderburn: But… And sender…

374
00:59:04.100 --> 00:59:07.240
Kevaundray Wedderburn: I don't know if that makes sense, so let me know…

375
00:59:16.870 --> 00:59:19.190
Kevaundray Wedderburn: Can you hear me? Oh, one sec.

376
00:59:19.550 --> 00:59:21.039
Zsolt Felföldi: Yes, yes, okay?

377
00:59:21.270 --> 00:59:23.340
Kevaundray Wedderburn: Yes, yeah.

378
00:59:23.450 --> 00:59:28.899
Kevaundray Wedderburn: So yeah, basically, you just need to know how to access those accelerators.

379
00:59:31.350 --> 00:59:49.130
Kevaundray Wedderburn: I can probably talk to you about it offline for when you do get to it, but the ZKVMs usually provide a library that does all of the Excel… that does the access in itself, so you just call it like a regular library, and it won't do the naive thing, it will do the smart thing.

380
00:59:49.220 --> 00:59:52.539
Kevaundray Wedderburn: But I can definitely talk to you about it off… offline.

381
00:59:54.830 --> 01:00:09.589
Zsolt Felföldi: Okay, yeah, so, yeah, ATPL definitely needs some pointers to, yeah, implement this logic in a provable way, but, okay, so, so for now, the important thing is that

382
01:00:09.700 --> 01:00:22.529
Zsolt Felföldi: So this should be possible, basically, yeah, so all those things that I need is… yeah, so I do need recursive prEOFs, and I do need hash acceleration, and yeah, that's pretty much…

383
01:00:23.970 --> 01:00:25.310
Zsolt Felföldi: what I need…

384
01:00:25.310 --> 01:00:25.890
Kevaundray Wedderburn: Yeah.

385
01:00:26.050 --> 01:00:32.430
Kevaundray Wedderburn: But you can do it in two separate steps, right? Like, the recursive prEOF is, like, a separate program you can think of.

386
01:00:32.720 --> 01:00:34.909
Kevaundray Wedderburn: That just does the merging.

387
01:00:35.290 --> 01:00:42.489
Kevaundray Wedderburn: Of prEOFs, whereas you have your core logic that just, does this table indexing.

388
01:00:42.980 --> 01:00:43.969
Kevaundray Wedderburn: So it's, like, two days.

389
01:00:43.970 --> 01:00:44.740
Zsolt Felföldi: Wait.

390
01:00:44.860 --> 01:00:45.640
Kevaundray Wedderburn: rooms.

391
01:00:46.540 --> 01:00:52.610
Zsolt Felföldi: Oh, so, so, so you're saying that I shouldn't mix these two logics together?

392
01:00:53.540 --> 01:01:07.090
Kevaundray Wedderburn: Yeah, I think it might be easier to separate it, as in you have your core logic, and then you have a thing that takes in, let's say, two prEOFs, and just merges them together, so all it does is just prEOF merging.

393
01:01:08.630 --> 01:01:09.440
Zsolt Felföldi: Ice…

394
01:01:09.930 --> 01:01:28.779
Zsolt Felföldi: So, so, like, I would have, like, two, verifier functions, and one of them would just have these, these, these Mercker prEOFs as, input, this index antimer prEOFs, and the other one would just have the…

395
01:01:28.800 --> 01:01:31.460
Zsolt Felföldi: The recursive prEOFs as input.

396
01:01:32.030 --> 01:01:33.419
Kevaundray Wedderburn: Right, right, exactly.

397
01:01:33.420 --> 01:01:35.010
Zsolt Felföldi: And…

398
01:01:35.400 --> 01:01:39.089
Zsolt Felföldi: Okay, okay, let's maybe, yeah, simplifies things a bit.

399
01:01:39.330 --> 01:01:53.489
Zsolt Felföldi: But still, like, if I merge together ZK prEOFs, like, recursively, I still need to somehow access the public part of those prEOFs, so that I know what…

400
01:01:54.380 --> 01:01:59.659
Zsolt Felföldi: what, content time merging together, so… but I guess that should be possible.

401
01:02:00.370 --> 01:02:06.829
Kevaundray Wedderburn: Right, right. Yeah, you just make it a public input, and it should come with the prEOF. You can think of it as…

402
01:02:07.690 --> 01:02:14.389
Zsolt Felföldi: Yeah, well, I… pretty much how I imagined it. Anyway, so yeah, this is…

403
01:02:14.450 --> 01:02:28.170
Zsolt Felföldi: this is… so yeah, this would be the public input, either full table chains or partially proven tables. And, yeah, so basically, I would have one function that takes two of these.

404
01:02:28.700 --> 01:02:29.820
Zsolt Felföldi: And,

405
01:02:30.020 --> 01:02:40.289
Zsolt Felföldi: somehow we also assume that the prEOF part would be requestively verified, but yeah, so what I need to care about is merging two of these together.

406
01:02:40.780 --> 01:02:41.670
Kevaundray Wedderburn: Right?

407
01:02:41.880 --> 01:02:43.220
Kevaundray Wedderburn: Right, right, exactly.

408
01:02:44.750 --> 01:02:52.310
Zsolt Felföldi: Okay, and the, in the other, other, other case, yeah, generating, this from, from, like, the…

409
01:02:54.140 --> 01:03:01.960
Zsolt Felföldi: three prEOFs. So, yeah, okay, I, I will, I will read, read, read upon, on the links you sent, and,

410
01:03:02.090 --> 01:03:07.769
Zsolt Felföldi: And yeah, let's… let's continue this offline. But yeah, this was really useful, and I think we already…

411
01:03:08.210 --> 01:03:10.090
Zsolt Felföldi: Past 1 hour or so, yeah.

412
01:03:11.680 --> 01:03:12.230
Zsolt Felföldi: Okay.

413
01:03:12.230 --> 01:03:12.680
Kevaundray Wedderburn: Sure, thanks.

414
01:03:12.680 --> 01:03:15.250
Zsolt Felföldi: Yeah, it was really useful, so yeah, thank you very much.

415
01:03:16.690 --> 01:03:17.820
Kevaundray Wedderburn: Okay.

416
01:03:18.290 --> 01:03:21.040
Kevaundray Wedderburn: No worries. Alright, see you, Joel. Thank you.

417
01:03:22.510 --> 01:03:24.689
Zsolt Felföldi: Okay, thank you, see you, bye-bye.

